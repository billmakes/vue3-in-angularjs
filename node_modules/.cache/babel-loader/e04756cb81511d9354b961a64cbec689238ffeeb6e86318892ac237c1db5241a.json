{"ast":null,"code":"/**\n * \n * AngularJs directive to render Vue component inside AngularJs code without extra binding\n * It supports one-time binding(not one-way binding) from the given html attributes\n * \n * How does it work?\n *   1. Read the element name, and use it to find a Vue component from a key/value registry\n *   2. Get attributes, and use it to this element scope\n *   3. Using the element name and attributes, initialize a vue component to this element\n * \n * References\n *  . https://v3.vuejs.org/guide/component-basics.html#dynamic-components\n *  . https://v3.vuejs.org/guide/instance.html#the-root-component\n *  . https://docs.angularjs.org/guide/directive\n * \n */\nimport * as Vue from 'vue';\nimport MyVueComponent from './my-vue-component.vue';\nimport MyOtherVueComponent from './my-other-vue-component.vue';\n\n// Vue comonent registry\nconst VUE_COMPONENTS = {\n  MyVueComponent,\n  MyOtherVueComponent\n};\n\n// Build a dynamic scope for compile\n// Works with foo=\"scopeVar\" bar=\"$ctrl.ctrlVar\" baz=\"'STRING'\" foo-bar=\"\" ng-vue\nfunction getAngularScopeFromAttrs(scope, attrs) {\n  const excludes = ['name', 'class'];\n  const newScope = {};\n  for (let key in attrs.$attr) {\n    if (excludes.includes(key)) continue; // skip common attributes\n    const ngExpr = attrs[key].match(/^([^;]*);?/)[1]; // 4 security, e.g., '$ctrl.foo;attack()'\n    if (ngExpr.match(/^'.*'$/)) {\n      // string expression. e.g. baz=\"'hello'\"\n      console.log('string expression', {\n        key,\n        ngExpr\n      });\n      newScope[key] = eval(`{ngExpr}`);\n    } else if (key.match(/^ng[A-Z]/)) {// angularJs events or angularJs attributes\n    } else if (key.match(/^vOn[A-Z]/)) {// vue events\n    } else if (ngExpr) {\n      // ignore empty attribute\n      console.log('angular expression', {\n        key,\n        ngExpr\n      }, scope.$parent);\n      newScope[key] = eval(`scope.${ngExpr}`);\n    }\n  }\n  return newScope;\n}\nfunction getVueEventAttrs(attrs) {\n  return Object.keys(attrs.$attr).filter(el => el.match(/^vOn[A-Z]/)).map(key => {\n    const attrName = attrs.$attr[key].replace(/v-on:/, '');\n    const expr = attrs[key];\n    return `v-on:${attrName}=\"handleEvents($event, '${attrName}', '${expr}')\"`;\n  });\n}\nfunction getVueComponent(tagName, VUE_COMPONENTS) {\n  const [_, component] = Object.entries(VUE_COMPONENTS).find(([key, value]) => {\n    return key.toLowerCase() === tagName.replace(/-/g);\n  });\n  return component;\n}\n\n// why directive? Because component can't be used with attribute\nconst NgVueDirective = function ($compile, $parse) {\n  return {\n    compile: function (element, attrs) {\n      const tagName = element[0].tagName.toLowerCase();\n      const vueComponent = getVueComponent(tagName, VUE_COMPONENTS);\n      return function (scope, element, attrs, ctrl, transcl) {\n        const newScope = getAngularScopeFromAttrs(scope, attrs);\n        for (let key in newScope) {\n          scope[key] = newScope[key];\n        }\n\n        // Insert a Vue component to this element\n        const vueEventAttrs = getVueEventAttrs(attrs).join(' ');\n        const vuePropsAttrs = Object.keys(newScope).map(key => `v-bind:${key}=\"${key}\"`).join(' ');\n        element[0].innerHTML = `<${tagName} ${vuePropsAttrs} ${vueEventAttrs}></${tagName}>`;\n        const app = Vue.createApp({\n          data: _ => newScope,\n          methods: {\n            handleEvents: ($event, eventName, expr) => {\n              const ngExpr = expr.match(/^([^;]*);?/)[1]; // 4 security, e.g., '$ctrl.foo;attack()'\n              eval(`scope.${ngExpr}`);\n            }\n          }\n        });\n        app.component(tagName, vueComponent); // Define Vue component given from attribute\n        app.mount(element[0]); // Vueify this element\n      };\n    }\n  };\n};\n\nexport default NgVueDirective;","map":{"version":3,"names":["Vue","MyVueComponent","MyOtherVueComponent","VUE_COMPONENTS","getAngularScopeFromAttrs","scope","attrs","excludes","newScope","key","$attr","includes","ngExpr","match","console","log","eval","$parent","getVueEventAttrs","Object","keys","filter","el","map","attrName","replace","expr","getVueComponent","tagName","_","component","entries","find","value","toLowerCase","NgVueDirective","$compile","$parse","compile","element","vueComponent","ctrl","transcl","vueEventAttrs","join","vuePropsAttrs","innerHTML","app","createApp","data","methods","handleEvents","$event","eventName","mount"],"sources":["/home/bill/tmp/vang/src/ng-vue-directive.js"],"sourcesContent":["/**\n * \n * AngularJs directive to render Vue component inside AngularJs code without extra binding\n * It supports one-time binding(not one-way binding) from the given html attributes\n * \n * How does it work?\n *   1. Read the element name, and use it to find a Vue component from a key/value registry\n *   2. Get attributes, and use it to this element scope\n *   3. Using the element name and attributes, initialize a vue component to this element\n * \n * References\n *  . https://v3.vuejs.org/guide/component-basics.html#dynamic-components\n *  . https://v3.vuejs.org/guide/instance.html#the-root-component\n *  . https://docs.angularjs.org/guide/directive\n * \n */\nimport * as Vue from 'vue';\nimport MyVueComponent from './my-vue-component.vue';\nimport MyOtherVueComponent from './my-other-vue-component.vue';\n\n// Vue comonent registry\nconst VUE_COMPONENTS = {\n  MyVueComponent, MyOtherVueComponent\n}\n\n// Build a dynamic scope for compile\n// Works with foo=\"scopeVar\" bar=\"$ctrl.ctrlVar\" baz=\"'STRING'\" foo-bar=\"\" ng-vue\nfunction getAngularScopeFromAttrs(scope, attrs) {\n  const excludes = ['name', 'class'];\n  const newScope = {};\n  for (let key in attrs.$attr) {\n    if (excludes.includes(key)) continue; // skip common attributes\n    const ngExpr = attrs[key].match(/^([^;]*);?/)[1]; // 4 security, e.g., '$ctrl.foo;attack()'\n    if (ngExpr.match(/^'.*'$/)) { // string expression. e.g. baz=\"'hello'\"\n      console.log('string expression', { key, ngExpr })\n      newScope[key] = eval(`{ngExpr}`);\n    } else if (key.match(/^ng[A-Z]/)) { // angularJs events or angularJs attributes\n    } else if (key.match(/^vOn[A-Z]/)) { // vue events\n    } else if (ngExpr) { // ignore empty attribute\n      console.log('angular expression', { key, ngExpr }, scope.$parent)\n      newScope[key] = eval(`scope.${ngExpr}`);\n    }\n  }\n  return newScope;\n}\n\nfunction getVueEventAttrs(attrs) {\n  return Object.keys(attrs.$attr).filter(el => el.match(/^vOn[A-Z]/))\n    .map(key => {\n      const attrName = attrs.$attr[key].replace(/v-on:/, '');\n      const expr = attrs[key];\n      return `v-on:${attrName}=\"handleEvents($event, '${attrName}', '${expr}')\"`;\n    });\n}\n\nfunction getVueComponent(tagName, VUE_COMPONENTS) {\n  const [_, component] = Object.entries(VUE_COMPONENTS).find(([key, value]) => {\n    return (key.toLowerCase() === tagName.replace(/-/g,));\n  });\n\n  return component;\n}\n\n// why directive? Because component can't be used with attribute\nconst NgVueDirective = function($compile, $parse) {\n  return {\n    compile: function(element, attrs) {\n      const tagName = element[0].tagName.toLowerCase();\n      const vueComponent = getVueComponent(tagName, VUE_COMPONENTS);\n\n      return function(scope, element, attrs, ctrl, transcl) {\n        const newScope = getAngularScopeFromAttrs(scope, attrs);\n        for (let key in newScope) {\n          scope[key] = newScope[key];\n        }\n\n        // Insert a Vue component to this element\n        const vueEventAttrs = getVueEventAttrs(attrs).join(' ');\n        const vuePropsAttrs = Object.keys(newScope).map(key => `v-bind:${key}=\"${key}\"`).join(' ');\n        element[0].innerHTML = `<${tagName} ${vuePropsAttrs} ${vueEventAttrs}></${tagName}>`;\n        const app = Vue.createApp({\n          data: _ => newScope,\n          methods: {\n            handleEvents: ($event, eventName, expr) => {\n              const ngExpr = expr.match(/^([^;]*);?/)[1]; // 4 security, e.g., '$ctrl.foo;attack()'\n              eval(`scope.${ngExpr}`);\n            }\n          }\n        });\n        app.component(tagName, vueComponent);  // Define Vue component given from attribute\n        app.mount(element[0]); // Vueify this element\n      }\n    }\n  };\n};\n\nexport default NgVueDirective;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,KAAKA,GAAG,MAAM,KAAK;AAC1B,OAAOC,cAAc,MAAM,wBAAwB;AACnD,OAAOC,mBAAmB,MAAM,8BAA8B;;AAE9D;AACA,MAAMC,cAAc,GAAG;EACrBF,cAAc;EAAEC;AAClB,CAAC;;AAED;AACA;AACA,SAASE,wBAAwB,CAACC,KAAK,EAAEC,KAAK,EAAE;EAC9C,MAAMC,QAAQ,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC;EAClC,MAAMC,QAAQ,GAAG,CAAC,CAAC;EACnB,KAAK,IAAIC,GAAG,IAAIH,KAAK,CAACI,KAAK,EAAE;IAC3B,IAAIH,QAAQ,CAACI,QAAQ,CAACF,GAAG,CAAC,EAAE,SAAS,CAAC;IACtC,MAAMG,MAAM,GAAGN,KAAK,CAACG,GAAG,CAAC,CAACI,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAClD,IAAID,MAAM,CAACC,KAAK,CAAC,QAAQ,CAAC,EAAE;MAAE;MAC5BC,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAE;QAAEN,GAAG;QAAEG;MAAO,CAAC,CAAC;MACjDJ,QAAQ,CAACC,GAAG,CAAC,GAAGO,IAAI,CAAE,UAAS,CAAC;IAClC,CAAC,MAAM,IAAIP,GAAG,CAACI,KAAK,CAAC,UAAU,CAAC,EAAE,CAAE;IAAA,CACnC,MAAM,IAAIJ,GAAG,CAACI,KAAK,CAAC,WAAW,CAAC,EAAE,CAAE;IAAA,CACpC,MAAM,IAAID,MAAM,EAAE;MAAE;MACnBE,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE;QAAEN,GAAG;QAAEG;MAAO,CAAC,EAAEP,KAAK,CAACY,OAAO,CAAC;MACjET,QAAQ,CAACC,GAAG,CAAC,GAAGO,IAAI,CAAE,SAAQJ,MAAO,EAAC,CAAC;IACzC;EACF;EACA,OAAOJ,QAAQ;AACjB;AAEA,SAASU,gBAAgB,CAACZ,KAAK,EAAE;EAC/B,OAAOa,MAAM,CAACC,IAAI,CAACd,KAAK,CAACI,KAAK,CAAC,CAACW,MAAM,CAACC,EAAE,IAAIA,EAAE,CAACT,KAAK,CAAC,WAAW,CAAC,CAAC,CAChEU,GAAG,CAACd,GAAG,IAAI;IACV,MAAMe,QAAQ,GAAGlB,KAAK,CAACI,KAAK,CAACD,GAAG,CAAC,CAACgB,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;IACtD,MAAMC,IAAI,GAAGpB,KAAK,CAACG,GAAG,CAAC;IACvB,OAAQ,QAAOe,QAAS,2BAA0BA,QAAS,OAAME,IAAK,KAAI;EAC5E,CAAC,CAAC;AACN;AAEA,SAASC,eAAe,CAACC,OAAO,EAAEzB,cAAc,EAAE;EAChD,MAAM,CAAC0B,CAAC,EAAEC,SAAS,CAAC,GAAGX,MAAM,CAACY,OAAO,CAAC5B,cAAc,CAAC,CAAC6B,IAAI,CAAC,CAAC,CAACvB,GAAG,EAAEwB,KAAK,CAAC,KAAK;IAC3E,OAAQxB,GAAG,CAACyB,WAAW,EAAE,KAAKN,OAAO,CAACH,OAAO,CAAC,IAAI,CAAE;EACtD,CAAC,CAAC;EAEF,OAAOK,SAAS;AAClB;;AAEA;AACA,MAAMK,cAAc,GAAG,UAASC,QAAQ,EAAEC,MAAM,EAAE;EAChD,OAAO;IACLC,OAAO,EAAE,UAASC,OAAO,EAAEjC,KAAK,EAAE;MAChC,MAAMsB,OAAO,GAAGW,OAAO,CAAC,CAAC,CAAC,CAACX,OAAO,CAACM,WAAW,EAAE;MAChD,MAAMM,YAAY,GAAGb,eAAe,CAACC,OAAO,EAAEzB,cAAc,CAAC;MAE7D,OAAO,UAASE,KAAK,EAAEkC,OAAO,EAAEjC,KAAK,EAAEmC,IAAI,EAAEC,OAAO,EAAE;QACpD,MAAMlC,QAAQ,GAAGJ,wBAAwB,CAACC,KAAK,EAAEC,KAAK,CAAC;QACvD,KAAK,IAAIG,GAAG,IAAID,QAAQ,EAAE;UACxBH,KAAK,CAACI,GAAG,CAAC,GAAGD,QAAQ,CAACC,GAAG,CAAC;QAC5B;;QAEA;QACA,MAAMkC,aAAa,GAAGzB,gBAAgB,CAACZ,KAAK,CAAC,CAACsC,IAAI,CAAC,GAAG,CAAC;QACvD,MAAMC,aAAa,GAAG1B,MAAM,CAACC,IAAI,CAACZ,QAAQ,CAAC,CAACe,GAAG,CAACd,GAAG,IAAK,UAASA,GAAI,KAAIA,GAAI,GAAE,CAAC,CAACmC,IAAI,CAAC,GAAG,CAAC;QAC1FL,OAAO,CAAC,CAAC,CAAC,CAACO,SAAS,GAAI,IAAGlB,OAAQ,IAAGiB,aAAc,IAAGF,aAAc,MAAKf,OAAQ,GAAE;QACpF,MAAMmB,GAAG,GAAG/C,GAAG,CAACgD,SAAS,CAAC;UACxBC,IAAI,EAAEpB,CAAC,IAAIrB,QAAQ;UACnB0C,OAAO,EAAE;YACPC,YAAY,EAAE,CAACC,MAAM,EAAEC,SAAS,EAAE3B,IAAI,KAAK;cACzC,MAAMd,MAAM,GAAGc,IAAI,CAACb,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;cAC5CG,IAAI,CAAE,SAAQJ,MAAO,EAAC,CAAC;YACzB;UACF;QACF,CAAC,CAAC;QACFmC,GAAG,CAACjB,SAAS,CAACF,OAAO,EAAEY,YAAY,CAAC,CAAC,CAAE;QACvCO,GAAG,CAACO,KAAK,CAACf,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACzB,CAAC;IACH;EACF,CAAC;AACH,CAAC;;AAED,eAAeJ,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}